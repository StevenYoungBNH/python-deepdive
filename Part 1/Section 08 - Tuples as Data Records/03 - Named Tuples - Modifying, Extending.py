#!/usr/bin/env python
# coding: utf-8

# ### Named Tuples - Modifying and Extending

# In[1]:


from collections import namedtuple


# In[2]:


Point2D = namedtuple('Point2D', 'x y')


# The objects generated by `namedtuple` generated classes are **immutable**.
# 
# In other words the following will not work:

# In[3]:


origin = Point2D(10,0)


# In[4]:


origin.x = 0


# However, we may want to "change" the value of one of the coordinates of our `origin` variable.
# 
# This is just like strings, we have to create a new version of the tuple, and assign it to the same label.
# 
# Suppose we want to change the x-coordinate of our `origin` to something else, but retain whatever the y-coordinate was.
# 
# We could do it as follows:

# In[5]:


origin = Point2D(0, origin.y)


# In[6]:


origin


# Of course this could become quite unwieldy when we have a larger number of properties and we only need to change a single item:

# In[7]:


Stock = namedtuple('Stock', 'symbol year month day open high low close')


# In[8]:


djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)


# To update the `close` property for example, we could write:

# In[9]:


djia = Stock(djia.symbol, djia.year, djia.month, djia.day, 
                  djia.open, djia.high, djia.low, 26_394)


# Now that was quite painful!
# 
# We can be a bit more clever about this and use tuple unpacking and argument unpacking as follows:

# In[10]:


*values, _ = djia


# We didn't care about the `close` price since we are replacing it, hence the underscore variable name.
# 
# And we now have everything else in a list:

# In[11]:


values


# And now we are going to use the `*` again, but this time to unpack the list into separate arguments when we call the `Stock` initializer:

# In[12]:


djia = Stock(*values, 26_393)


# In[13]:


djia


# This is much better than our first attempt!
# 
# But this approach does not always work, what happens if we want to change a values somewhere in the middle? Or two values?
# 
# We cannot do: 
# `*first, month, *last = djia`
# 
# That would make no sense whatsoever! (and Python will tell you so!)
# 
# Maybe slicing and unpacking can work here...

# In[14]:


djia


# We could try **slicing**:

# In[15]:


djia[:3]


# In[16]:


djia[:3] + (26,) + djia[4:]


# So now we could use this to create a new StockPrice instance:

# In[17]:


djia2 = Stock(*(djia[:3] + (26,) + djia[4:]))


# In[18]:


djia2


# This works, but that's quite cumbersome...
# 
# And it gets worse - suppose we want to modify the year and day using this approach:

# In[19]:


djia


# In[20]:


values = djia[0:1] + (2019,) + djia[2:3] + (26,) + djia[4:]


# In[21]:


values


# In[22]:


djia3 = Stock(*values)


# In[23]:


djia3


# Or, if you want to avoid unpacking the `values` into the multiple positional arguments required by the `Stock` constructor, we can make us of the `_make` class method that can use an iterable:

# In[24]:


djia4 = Stock._make(values)


# In[25]:


djia4


# This is really getting too complex.
# 
# Fortunately there's a better way!
# 
# The namedtuple implementation also provides another instance method called `_replace` which takes keyword-only arguments. That method will make a copy of the current tuple and substitute property values based on the keyword-only arguments passed in.

# In[26]:


djia


# In[27]:


id(djia)


# In[28]:


djia5 = djia._replace(year=2019, day=26)


# In[29]:


djia5


# In[30]:


djia


# In[31]:


id(djia5)


# Much better!!

# #### Extending Named Tuples

# Sometimes we may want to add one or more properties to an existing class without modifying the code for the custom class itself.
# 
# Using inheritance is one way to go about it so you may be tempted to do this with named tuples as well, but it's not easy, and there's a cleaner way to do this if all you're after is additional data fields.
# 
# Let's say we have a Point class that is for 2D problems:

# In[32]:


Point2D = namedtuple('Point2D', 'x y')


# We could easily create a 3D point class as follows:

# In[33]:


Point3D = namedtuple('Point3D', 'x y z')


# But if our named tuple has many fields, such as our `Stock` named tuple that's a little more difficult:

# In[34]:


djia


# Suppose we want to create a new class, say `StockExt`, it would take some effort:

# In[35]:


StockExt = namedtuple('StockExt', 
                      '''symbol year month day open high low 
                      close previous_close''')


# Instead we can leverage that `_fields` property:

# In[36]:


Stock._fields


# Remember that the `namedtuple` initializer can handle a list or tuple containing the field names. For example, the one we just retrieved from `_fields`.
# 
# Now all we need to do is create a new tuple that contains those fields along with whatever extras we want:

# In[37]:


new_fields = Stock._fields + ('previous_close',)


# In[38]:


new_fields


# And now we can create our new named tuple this way:

# In[39]:


StockExt = namedtuple('StockExt', Stock._fields + ('previous_close',))


# In[40]:


StockExt._fields


# If you did not want to use tuple concatenation for some reason, you could also do it using strings:

# In[41]:


' '.join(Stock._fields) + ' previous_close'


# In[42]:


StockExt = namedtuple('StockExt', 
                      ' '.join(Stock._fields) + ' previous_close')


# In[43]:


StockExt._fields


# Now, with this newly extended class, we may want to take one of the "old" named tuple instance (`djia`) and create the extended version of it using the `StockExt` class.
# 
# This is also quite simple to do, since named tuples are tuples, and can therefore be unpacked in the arguments of a function call.

# In[44]:


djia


# In[45]:


djia_ext = StockExt(*djia, 25_000)


# In[46]:


djia_ext


# or, we can use the `_make` method:

# In[47]:


djia_ext = StockExt._make(djia + (25_000, ))


# In[48]:


djia_ext

